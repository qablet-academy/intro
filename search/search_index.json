{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Qablet timetable defines a financial contract using a sequence of payments, choices and conditions. A valuation model implemented with a Qablet parser can value any contract, as long as the contract can be described using a timetable such as this one - track time op quantity unit 0 #1 03/31/2024 > 0.0 USD 1 #1 03/31/2024 + -2900.0 USD 2 #1 03/31/2024 + 1.0 SPX Overview Start with Getting Started For the model specific details see the MODELS section. For viewing various stats see the STATS section. Other Resources Qablet Contracts documents the timetable semantics, and a library of contract classes. Qablet Learning Path is a set of Jupyter notebooks from simple to advanced uses of Qablet. Qablet App is an interactive showcase of several Qablet contracts, with pricing and backtesting.","title":"Home"},{"location":"#overview","text":"Start with Getting Started For the model specific details see the MODELS section. For viewing various stats see the STATS section.","title":"Overview"},{"location":"#other-resources","text":"Qablet Contracts documents the timetable semantics, and a library of contract classes. Qablet Learning Path is a set of Jupyter notebooks from simple to advanced uses of Qablet. Qablet App is an interactive showcase of several Qablet contracts, with pricing and backtesting.","title":"Other Resources"},{"location":"assets/","text":"Assets The ASSETS component of the dataset describes the forwards of each asset that would be required to value a contract. This includes the base asset (currency) in which the contract is valued any asset (currency, equity, commodity) received by the contract any asset value used in a snapper, or in a model In the present version the following schemas are supported to describe the forwards. This list will be extended in coming versions. Zero Rates You can describe the base asset using a two-column (N X 2) numpy array, where the first column is time, and the second represents term zero rates , e.g. [[0. 0.04] [1. 0.04] [5. 0.05]] It can be created like discount_data = (\"ZERO_RATES\", np.array([[0.0, 0.04], [1.0, .04], [5.0, 0.05]])) dataset = { \"BASE\": \"USD\", \"PRICING_TS\": .. \"ASSETS\": {\"USD\": discount_data}, } Or alternatively, using np.column_stack from two arrays times = np.array([0.0, 1.0, 5.0]) rates = np.array([0.04, 0.04, 0.05]) discount_data = (\"ZERO_RATES\", np.column_stack((times, rates))) Forwards You can describe any asset using a two-column (N X 2) numpy array, where the first column is time, and the second represents forwards, e.g. spot = 2900 div_rate = 0.01 times = np.array([0.0, 1.0, 2.0, 5.0]) rates = np.array([0.04, 0.04, 0.045, 0.05]) fwds = spot * np.exp((rates - div_rate) * times) fwd_data = (\"FORWARDS\", np.column_stack((times, fwds))) dataset = { \"BASE\": \"USD\", \"PRICING_TS\": .. \"ASSETS\": {\"SPX\": fwd_data}, }","title":"Assets"},{"location":"assets/#assets","text":"The ASSETS component of the dataset describes the forwards of each asset that would be required to value a contract. This includes the base asset (currency) in which the contract is valued any asset (currency, equity, commodity) received by the contract any asset value used in a snapper, or in a model In the present version the following schemas are supported to describe the forwards. This list will be extended in coming versions.","title":"Assets"},{"location":"assets/#zero-rates","text":"You can describe the base asset using a two-column (N X 2) numpy array, where the first column is time, and the second represents term zero rates , e.g. [[0. 0.04] [1. 0.04] [5. 0.05]] It can be created like discount_data = (\"ZERO_RATES\", np.array([[0.0, 0.04], [1.0, .04], [5.0, 0.05]])) dataset = { \"BASE\": \"USD\", \"PRICING_TS\": .. \"ASSETS\": {\"USD\": discount_data}, } Or alternatively, using np.column_stack from two arrays times = np.array([0.0, 1.0, 5.0]) rates = np.array([0.04, 0.04, 0.05]) discount_data = (\"ZERO_RATES\", np.column_stack((times, rates)))","title":"Zero Rates"},{"location":"assets/#forwards","text":"You can describe any asset using a two-column (N X 2) numpy array, where the first column is time, and the second represents forwards, e.g. spot = 2900 div_rate = 0.01 times = np.array([0.0, 1.0, 2.0, 5.0]) rates = np.array([0.04, 0.04, 0.045, 0.05]) fwds = spot * np.exp((rates - div_rate) * times) fwd_data = (\"FORWARDS\", np.column_stack((times, fwds))) dataset = { \"BASE\": \"USD\", \"PRICING_TS\": .. \"ASSETS\": {\"SPX\": fwd_data}, }","title":"Forwards"},{"location":"dataset/","text":"Dataset All models in the qablet package have a signature as follows: price, stats = model.price(timetable, dataset) The arg timetable is a qablet timetable . The arg dataset is a dict with the following components BASE String containing the name of the base asset, i.e. the currency in which the price is denominated. PRICING_TS The timestamp (milliseconds) that we will price the contract as of. ASSETS Dict containing forwards of all assets in the contract, including the base asset. See Assets for more. {Model Family Name} Dict containing parameters for the model family such as MC or FD . {Model Name} Dict containing parameters of the model. See the MODELS section for more. Example import numpy as np from datetime import datetime from qablet_contracts.timetable import py_to_ts times = np.array([0.0, 1.0, 2.0, 5.0]) # in years rates = np.array([0.04, 0.04, 0.045, 0.05]) # i.e. 4%, etc fwds = np.array([100.0, 101.0, 102.0, 104.0]) discount_data = (\"ZERO_RATES\", np.column_stack((times, rates))) fwd_data = (\"FORWARDS\", np.column_stack((times, fwds))) dataset = { \"BASE\": \"USD\", \"PRICING_TS\": py_to_ts(datetime(2023, 12, 31)).value, \"ASSETS\": {\"USD\": discount_data, \"SPX\": fwd_data}, \"MC\": { \"PATHS\": 100_000, \"TIMESTEP\": 1 / 250, \"SEED\": 1, }, \"HESTON\": { \"ASSET\": \"SPX\", \"INITIAL_VAR\": 0.015, \"LONG_VAR\": 0.052, \"VOL_OF_VAR\": 0.88, \"MEANREV\": 2.78, \"CORRELATION\": -0.85, } }","title":"Dataset"},{"location":"dataset/#dataset","text":"All models in the qablet package have a signature as follows: price, stats = model.price(timetable, dataset) The arg timetable is a qablet timetable . The arg dataset is a dict with the following components BASE String containing the name of the base asset, i.e. the currency in which the price is denominated. PRICING_TS The timestamp (milliseconds) that we will price the contract as of. ASSETS Dict containing forwards of all assets in the contract, including the base asset. See Assets for more. {Model Family Name} Dict containing parameters for the model family such as MC or FD . {Model Name} Dict containing parameters of the model. See the MODELS section for more.","title":"Dataset"},{"location":"dataset/#example","text":"import numpy as np from datetime import datetime from qablet_contracts.timetable import py_to_ts times = np.array([0.0, 1.0, 2.0, 5.0]) # in years rates = np.array([0.04, 0.04, 0.045, 0.05]) # i.e. 4%, etc fwds = np.array([100.0, 101.0, 102.0, 104.0]) discount_data = (\"ZERO_RATES\", np.column_stack((times, rates))) fwd_data = (\"FORWARDS\", np.column_stack((times, fwds))) dataset = { \"BASE\": \"USD\", \"PRICING_TS\": py_to_ts(datetime(2023, 12, 31)).value, \"ASSETS\": {\"USD\": discount_data, \"SPX\": fwd_data}, \"MC\": { \"PATHS\": 100_000, \"TIMESTEP\": 1 / 250, \"SEED\": 1, }, \"HESTON\": { \"ASSET\": \"SPX\", \"INITIAL_VAR\": 0.015, \"LONG_VAR\": 0.052, \"VOL_OF_VAR\": 0.88, \"MEANREV\": 2.78, \"CORRELATION\": -0.85, } }","title":"Example"},{"location":"quickstart/","text":"You will need the following packages. qablet-contracts contains utilities to create qablet timetables for financial contracts. qablet-basic contains a suite of models to evaluate qablet timetables. pip install qablet-contracts pip install qablet-basic Hello World This is a simple example of creating a zero coupon bond, and pricing it using a deterministic model. import numpy as np from pyarrow import RecordBatch as rb from datetime import datetime from qablet_contracts.timetable import TS_EVENT_SCHEMA, py_to_ts from qablet.base.fixed import FixedModel # Create Timetable events = [ { \"track\": \"\", \"time\": datetime(2024, 12, 31), \"op\": \"+\", \"quantity\": 100.0, \"unit\": \"USD\", }, ] timetable = { \"events\": rb.from_pylist(events, schema=TS_EVENT_SCHEMA) } # Create Dataset for FixedModel discount_data = (\"ZERO_RATES\", np.array([[0.0, 0.04], [5.0, 0.04]])) # 4% from 0-5 years dataset = { \"BASE\": \"USD\", \"PRICING_TS\": py_to_ts(datetime(2023, 12, 31)).value, \"ASSETS\": {\"USD\": discount_data}, } # Calculate Price with FixedModel model = FixedModel() price, _ = model.price(timetable, dataset) print(f\"price: {price:11.6f}\") Next Steps See Qablet Contracts to create timetables with payments, options, triggers and path dependent features. See Dataset API to construct a dataset from your market data. See Finite Difference/PDE and Monte Carlo models that comes with the qablet-basic package. We recommend that you bookmark the above references, and dive into the Qablet Learning Path next. It is a set of Jupyter notebooks that will walk you through simple to advanced uses of Qablet.","title":"Getting Started"},{"location":"quickstart/#hello-world","text":"This is a simple example of creating a zero coupon bond, and pricing it using a deterministic model. import numpy as np from pyarrow import RecordBatch as rb from datetime import datetime from qablet_contracts.timetable import TS_EVENT_SCHEMA, py_to_ts from qablet.base.fixed import FixedModel # Create Timetable events = [ { \"track\": \"\", \"time\": datetime(2024, 12, 31), \"op\": \"+\", \"quantity\": 100.0, \"unit\": \"USD\", }, ] timetable = { \"events\": rb.from_pylist(events, schema=TS_EVENT_SCHEMA) } # Create Dataset for FixedModel discount_data = (\"ZERO_RATES\", np.array([[0.0, 0.04], [5.0, 0.04]])) # 4% from 0-5 years dataset = { \"BASE\": \"USD\", \"PRICING_TS\": py_to_ts(datetime(2023, 12, 31)).value, \"ASSETS\": {\"USD\": discount_data}, } # Calculate Price with FixedModel model = FixedModel() price, _ = model.price(timetable, dataset) print(f\"price: {price:11.6f}\")","title":"Hello World"},{"location":"quickstart/#next-steps","text":"See Qablet Contracts to create timetables with payments, options, triggers and path dependent features. See Dataset API to construct a dataset from your market data. See Finite Difference/PDE and Monte Carlo models that comes with the qablet-basic package. We recommend that you bookmark the above references, and dive into the Qablet Learning Path next. It is a set of Jupyter notebooks that will walk you through simple to advanced uses of Qablet.","title":"Next Steps"},{"location":"models/fd/","text":"Finite Difference Models All Finite-Difference Models (one factor) include a common section ( FD ), and a model dependent section. Common Section The common section has the following parameters. TIMESTEP : The incremental timestep of simulation (in years). MAX_X : Distance of the upper (or lower) boundary of the model grid from the center. N_X : The number of levels from the center, in each direction. e.g. \"FD\": { \"TIMESTEP\": 1 / 250, \"MAX_X\": 0.1, \"N_X\": 250, }, Black-Scholes Model qablet.black_scholes.fd.BSFDModel In the Heston model the lognormal stock process X_t is given by, dX_t = (\\mu_t - \\frac{\\sigma^2}{2})dt + \\sigma dW_t The model specific component in the dataset ( BS ) is a dict with VOL ( \\sigma ), and the name of the asset: e.g. \"BS\": { \"ASSET\": \"SPX\", \"VOL\": 0.3, } Hull-White Model qablet.hullwhite.fd.HWFDModel In the Hull White model, the short-rate follows the following process. dr_t = [\\theta_t - a r_t]dt + \\sigma dW_t The model specific component in the dataset ( HW ) is a dict with the parameters: a , the mean reversion rate (MEANREV). \\sigma , the volatility (VOL). e.g. \"HW\": { \"MEANREV\": 0.1, \"VOL\": 0.03, }","title":"Finite-Difference"},{"location":"models/fd/#finite-difference-models","text":"All Finite-Difference Models (one factor) include a common section ( FD ), and a model dependent section.","title":"Finite Difference Models"},{"location":"models/fd/#common-section","text":"The common section has the following parameters. TIMESTEP : The incremental timestep of simulation (in years). MAX_X : Distance of the upper (or lower) boundary of the model grid from the center. N_X : The number of levels from the center, in each direction. e.g. \"FD\": { \"TIMESTEP\": 1 / 250, \"MAX_X\": 0.1, \"N_X\": 250, },","title":"Common Section"},{"location":"models/fd/#black-scholes-model","text":"qablet.black_scholes.fd.BSFDModel In the Heston model the lognormal stock process X_t is given by, dX_t = (\\mu_t - \\frac{\\sigma^2}{2})dt + \\sigma dW_t The model specific component in the dataset ( BS ) is a dict with VOL ( \\sigma ), and the name of the asset: e.g. \"BS\": { \"ASSET\": \"SPX\", \"VOL\": 0.3, }","title":"Black-Scholes Model"},{"location":"models/fd/#hull-white-model","text":"qablet.hullwhite.fd.HWFDModel In the Hull White model, the short-rate follows the following process. dr_t = [\\theta_t - a r_t]dt + \\sigma dW_t The model specific component in the dataset ( HW ) is a dict with the parameters: a , the mean reversion rate (MEANREV). \\sigma , the volatility (VOL). e.g. \"HW\": { \"MEANREV\": 0.1, \"VOL\": 0.03, }","title":"Hull-White Model"},{"location":"models/mc/","text":"Monte-Carlo Models All Monte-Carlo Models include a common section ( MC ), and a model dependent section. Common Section The common section has the following parameters. PATHS : The number of Monte-Carlo paths. TIMESTEP : The incremental timestep of simulation (in years). SEED : The seed for the random number generator. e.g. \"MC\": { \"PATHS\": 100_000, \"TIMESTEP\": 1 / 250, \"SEED\": 1, }, Heston Model qablet.heston.mc.HestonMCModel In the Heston model the lognormal stock process X_t is given by, dX_t = (\\mu - \\frac{\\nu_t}{2}) dt + \\sqrt \\nu_t dW_s and the variance follows the process d \\nu_t = \\kappa (\\theta - \\nu_t) dt + \\xi \\sqrt \\nu_tdW_t where dW_s and dW_t are Wiener processes with correlation \\rho . The model specific component in the dataset ( HESTON ) is a dict with five parameters, and the name of the asset: \\nu_0 , the initial variance (INITIAL_VAR). \\theta , the long variance (LONG_VAR). \\rho , the correlation (CORRELATION). \\kappa , the mean reversion rate (MEANREV)). \\xi , the volatility of the volatility (VOL_OF_VAR). e.g. \"HESTON\": { \"ASSET\": \"SPX\", \"INITIAL_VAR\": 0.015, \"LONG_VAR\": 0.052, \"VOL_OF_VAR\": 0.88, \"MEANREV\": 2.78, \"CORRELATION\": -0.85, } The model can be used as from qablet.heston.mc import HestonMCModel dataset = { \"BASE\": ... \"PRICING_TS\": ... \"ASSETS\": ... \"MC\": ... \"HESTON\": ... } heston_model = HestonMCModel() price, stats = model.price(timetable, dataset) Local Vol Model qablet.black_scholes.mc.LVMCModel In the Local Vol model the lognormal stock process X_t is given by, dX_t = (\\mu - \\frac{\\sigma_t^2}{2}) dt + \\sigma_t dW_s Where \\sigma_t is a function of X_t and t . The model specific component in the dataset ( LV ) is a dict with two parameters ASSET and VOL . Fixed Vol VOL can be a float as shown below, in which case it reduces to the Black-Scholes Model. \"LV\": { \"ASSET\": \"SPX\", \"VOL\": 0.015 } Vol Function VOL can be a function as below def volfn(points): # t is float, x_vec is a np array (t, x_vec) = points at = 5.0 * t + .01 atm = 0.04 + 0.01 * np.exp(-at) skew = -1.5 * (1 - np.exp(-at)) / at return np.sqrt(np.maximum(0.001, atm + x_vec * skew)) \"LV\": { \"ASSET\": \"SPX\", \"VOL\": volfn } Vol Interpolator VOL can be an interpolator as below from scipy.interpolate import RegularGridInterpolator times = [0.01, 0.2, 1.0] strikes = [-5.0, -0.5, -0.1, 0.0, 0.1, 0.5, 5.0] vols = np.array([ [2.713, 0.884, 0.442, 0.222, 0.032, 0.032, 0.032], [2.187, 0.719, 0.372, 0.209, 0.032, 0.032, 0.032], [1.237, 0.435, 0.264, 0.200, 0.101, 0.032, 0.032] ]) volinterp = RegularGridInterpolator( (times, strikes), vols, fill_value=None, bounds_error=False ) \"LV\": { \"ASSET\": \"SPX\", \"VOL\": volinterp } The model can be used as from qablet.black_scholes.mc import LVMCModel dataset = { \"BASE\": ... \"PRICING_TS\": ... \"ASSETS\": ... \"MC\": ... \"LV\": ... } heston_model = LVMCModel() price, stats = model.price(timetable, dataset)","title":"Monte-Carlo"},{"location":"models/mc/#monte-carlo-models","text":"All Monte-Carlo Models include a common section ( MC ), and a model dependent section.","title":"Monte-Carlo Models"},{"location":"models/mc/#common-section","text":"The common section has the following parameters. PATHS : The number of Monte-Carlo paths. TIMESTEP : The incremental timestep of simulation (in years). SEED : The seed for the random number generator. e.g. \"MC\": { \"PATHS\": 100_000, \"TIMESTEP\": 1 / 250, \"SEED\": 1, },","title":"Common Section"},{"location":"models/mc/#heston-model","text":"qablet.heston.mc.HestonMCModel In the Heston model the lognormal stock process X_t is given by, dX_t = (\\mu - \\frac{\\nu_t}{2}) dt + \\sqrt \\nu_t dW_s and the variance follows the process d \\nu_t = \\kappa (\\theta - \\nu_t) dt + \\xi \\sqrt \\nu_tdW_t where dW_s and dW_t are Wiener processes with correlation \\rho . The model specific component in the dataset ( HESTON ) is a dict with five parameters, and the name of the asset: \\nu_0 , the initial variance (INITIAL_VAR). \\theta , the long variance (LONG_VAR). \\rho , the correlation (CORRELATION). \\kappa , the mean reversion rate (MEANREV)). \\xi , the volatility of the volatility (VOL_OF_VAR). e.g. \"HESTON\": { \"ASSET\": \"SPX\", \"INITIAL_VAR\": 0.015, \"LONG_VAR\": 0.052, \"VOL_OF_VAR\": 0.88, \"MEANREV\": 2.78, \"CORRELATION\": -0.85, } The model can be used as from qablet.heston.mc import HestonMCModel dataset = { \"BASE\": ... \"PRICING_TS\": ... \"ASSETS\": ... \"MC\": ... \"HESTON\": ... } heston_model = HestonMCModel() price, stats = model.price(timetable, dataset)","title":"Heston Model"},{"location":"models/mc/#local-vol-model","text":"qablet.black_scholes.mc.LVMCModel In the Local Vol model the lognormal stock process X_t is given by, dX_t = (\\mu - \\frac{\\sigma_t^2}{2}) dt + \\sigma_t dW_s Where \\sigma_t is a function of X_t and t . The model specific component in the dataset ( LV ) is a dict with two parameters ASSET and VOL .","title":"Local Vol Model"},{"location":"models/mc/#fixed-vol","text":"VOL can be a float as shown below, in which case it reduces to the Black-Scholes Model. \"LV\": { \"ASSET\": \"SPX\", \"VOL\": 0.015 }","title":"Fixed Vol"},{"location":"models/mc/#vol-function","text":"VOL can be a function as below def volfn(points): # t is float, x_vec is a np array (t, x_vec) = points at = 5.0 * t + .01 atm = 0.04 + 0.01 * np.exp(-at) skew = -1.5 * (1 - np.exp(-at)) / at return np.sqrt(np.maximum(0.001, atm + x_vec * skew)) \"LV\": { \"ASSET\": \"SPX\", \"VOL\": volfn }","title":"Vol Function"},{"location":"models/mc/#vol-interpolator","text":"VOL can be an interpolator as below from scipy.interpolate import RegularGridInterpolator times = [0.01, 0.2, 1.0] strikes = [-5.0, -0.5, -0.1, 0.0, 0.1, 0.5, 5.0] vols = np.array([ [2.713, 0.884, 0.442, 0.222, 0.032, 0.032, 0.032], [2.187, 0.719, 0.372, 0.209, 0.032, 0.032, 0.032], [1.237, 0.435, 0.264, 0.200, 0.101, 0.032, 0.032] ]) volinterp = RegularGridInterpolator( (times, strikes), vols, fill_value=None, bounds_error=False ) \"LV\": { \"ASSET\": \"SPX\", \"VOL\": volinterp } The model can be used as from qablet.black_scholes.mc import LVMCModel dataset = { \"BASE\": ... \"PRICING_TS\": ... \"ASSETS\": ... \"MC\": ... \"LV\": ... } heston_model = LVMCModel() price, stats = model.price(timetable, dataset)","title":"Vol Interpolator"},{"location":"stats/choices/","text":"Stats: CHOICES TBD.","title":"Choices"},{"location":"stats/choices/#stats-choices","text":"TBD.","title":"Stats: CHOICES"},{"location":"stats/pvvec/","text":"Stats: PV_VEC TBD.","title":"Pvvec"},{"location":"stats/pvvec/#stats-pv_vec","text":"TBD.","title":"Stats: PV_VEC"}]}